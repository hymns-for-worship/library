import 'users.drift';

-- Tables
CREATE TABLE records (
    id TEXT PRIMARY KEY NOT NULL,
    collection_id TEXT NOT NULL,
    collection_name TEXT NOT NULL,
    data TEXT NOT NULL,
    deleted BOOLEAN NOT NULL DEFAULT 0,
    synced BOOLEAN NOT NULL DEFAULT 0,
    created DATETIME NOT NULL,
    updated DATETIME NOT NULL,
    UNIQUE (id, collection_id, collection_name)
);

CREATE VIEW user_records AS
SELECT 
    id,
    collection_id,
    collection_name, 
    synced,
    deleted,
    created,
    modified,
    data,
    CASE WHEN json_extract(data, '$.user') IS NOT NULL THEN CAST(json_extract(data, '$.user') AS TEXT) ELSE NULL END AS user,
    CASE WHEN json_extract(data, '$.uid') IS NOT NULL THEN CAST(json_extract(data, '$.uid') AS TEXT) ELSE NULL END AS uid
FROM records;

CREATE TRIGGER user_records_users_delete_trigger
AFTER DELETE ON users
FOR EACH ROW
BEGIN
    DELETE FROM user_records
    WHERE user = OLD.id;
END;

CREATE TABLE records_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    collection_name TEXT NOT NULL,
    synced BOOLEAN NOT NULL DEFAULT 0,
    created DATETIME NOT NULL,
    updated DATETIME NOT NULL,
    UNIQUE (collection_name)
);

-- Indexes
CREATE INDEX records_idx_collection ON records (collection_id, collection_name);
CREATE INDEX records_idx_data ON records (data);
CREATE INDEX records_idx_status ON records (deleted, synced);
CREATE INDEX records_idx_date ON records (created, updated);

getRecordModels:
SELECT * FROM records;

getRecordModel:
SELECT * FROM records
WHERE id = :id;

getRecordModelsByCollectionId:
SELECT * FROM records
WHERE collection_id = :collection_id;

getRecordModelByCollectionId:
SELECT * FROM records
WHERE collection_id = :collection_id
AND id = :id;

getRecordModelsByCollectionName:
SELECT * FROM records
WHERE collection_name = :collection_name;

getRecordModelByCollectionName:
SELECT * FROM records
WHERE collection_name = :collection_name
AND id = :id;

createRecordModel:
INSERT OR REPLACE INTO records (id, collection_id, collection_name, data, deleted, synced, created, updated)
VALUES (:id, :collection_id, :collection_name, :data, :deleted, :synced, :created, :updated);
RETURNING *;

updateRecordModel:
UPDATE records
SET data = :data, deleted = :deleted, synced = :synced, updated = :updated
WHERE id = :id;

deleteRecordModel:
DELETE FROM records
WHERE id = :id;

softDeleteRecordModel:
UPDATE records
SET deleted = 1, updated = :updated
WHERE id = :id;

setSyncStatusRecordModel:
UPDATE records
SET synced = :synced, updated = :updated
WHERE id = :id;

setDeleteStatusRecordModel:
UPDATE records
SET deleted = :deleted, updated = :updated
WHERE id = :id;

deleteRecordModelByCollectionId:
DELETE FROM records
WHERE collection_id = :collection_id;

deleteRecordModelByCollectionName:
DELETE FROM records
WHERE collection_name = :collection_name;

deleteRecordModelByCollectionIdAndId:
DELETE FROM records
WHERE collection_id = :collection_id
AND id = :id;

deleteRecordModelByCollectionNameAndId:
DELETE FROM records
WHERE collection_name = :collection_name
AND id = :id;

deleteAllRecordModels:
DELETE FROM records;

deleteRecordModelsByCollectionNameBeforeDate:
DELETE FROM records
WHERE collection_name = :collection_name AND updated < :date;

getCollectionNameSyncedStatus:
SELECT * FROM records_cache
WHERE collection_name = :collection_name;

setCollectionSyncedStatus:
INSERT OR REPLACE INTO records_cache (collection_name, synced, created, updated)
VALUES (:collection_name, :synced, :created, :updated);
